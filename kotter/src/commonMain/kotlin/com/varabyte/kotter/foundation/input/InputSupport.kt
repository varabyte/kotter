package com.varabyte.kotter.foundation.input

import com.varabyte.kotter.foundation.anim.Anim
import com.varabyte.kotter.foundation.text.*
import com.varabyte.kotter.foundation.timer.addTimer
import com.varabyte.kotter.platform.collections.computeIfAbsent
import com.varabyte.kotter.platform.runtime.getCurrentTimeMs
import com.varabyte.kotter.runtime.*
import com.varabyte.kotter.runtime.concurrent.ConcurrentScopedData
import com.varabyte.kotter.runtime.concurrent.createKey
import com.varabyte.kotter.runtime.concurrent.locks.ReentrantLock
import com.varabyte.kotter.runtime.concurrent.locks.withLock
import com.varabyte.kotter.runtime.internal.ansi.Ansi
import com.varabyte.kotter.runtime.terminal.Terminal
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlin.time.Duration

// Once created, we keep it alive for the session, because Flow is designed to be collected multiple times, meaning
// there's no reason for us to keep recreating it. It's pretty likely that if a session uses input in one block, it
// will use input again in others. (We can always revisit this decision later and scope this to a Section lifecycle
// instead)
private val KeyFlowKey = Session.Lifecycle.createKey<Flow<Key>>()

/**
 * Create a [Flow<Key>] value which converts bytes read from a terminal into keys, handling some gnarly multibyte
 * cases and smoothing over other inconsistent, historical legacy.
 */
private fun ConcurrentScopedData.prepareKeyFlow(terminal: Terminal, ioDispatcher: CoroutineDispatcher) {
    tryPut(KeyFlowKey) {
        val keyLock = ReentrantLock()
        val escSeq = StringBuilder()
        var lastKeyTime: Long
        channelFlow {
            terminal.read().collect { byte ->
                val c = byte.toChar()
                val key = keyLock.withLock {
                    lastKeyTime = getCurrentTimeMs()
                    when {
                        escSeq.isNotEmpty() -> {
                            // Normally, we get here if we're continuing an existing esc sequence, but if so some reason
                            // a previous one was never consumed *and* we are starting a new ESC sequence, just clear
                            // out anything left over from before. This could happen for example if the user just
                            // pressed ESC (which puts an ESC in the escSeq queue and waits a while before sending it
                            // out), but maybe also we end up getting an escape sequence that we didn't know how to
                            // handle, and without doing this, that old sequence would block us from working ever again.
                            if (c == Ansi.CtrlChars.ESC) escSeq.clear()

                            escSeq.append(c)
                            val code = Ansi.EscSeq.toCsiCode(escSeq)
                            if (code != null) {
                                escSeq.clear()
                                when (code) {
                                    Ansi.Csi.Codes.Keys.UP -> Keys.UP
                                    Ansi.Csi.Codes.Keys.DOWN -> Keys.DOWN
                                    Ansi.Csi.Codes.Keys.LEFT -> Keys.LEFT
                                    Ansi.Csi.Codes.Keys.RIGHT -> Keys.RIGHT
                                    Ansi.Csi.Codes.Keys.HOME, Ansi.Csi.Codes.Cursor.MOVE_TO_LINE_START -> Keys.HOME
                                    Ansi.Csi.Codes.Keys.INSERT -> Keys.INSERT
                                    Ansi.Csi.Codes.Keys.DELETE -> Keys.DELETE
                                    Ansi.Csi.Codes.Keys.END, Ansi.Csi.Codes.Cursor.MOVE_TO_LINE_END -> Keys.END
                                    Ansi.Csi.Codes.Keys.PG_UP -> Keys.PAGE_UP
                                    Ansi.Csi.Codes.Keys.PG_DOWN -> Keys.PAGE_DOWN
                                    else -> null
                                }
                            } else {
                                null
                            }
                        }
                        else -> {
                            when (c) {
                                Ansi.CtrlChars.EOF -> Keys.EOF
                                // Windows uses BACKSPACE, *nix uses DELETE? Best to support both
                                Ansi.CtrlChars.BACKSPACE, Ansi.CtrlChars.DELETE -> Keys.BACKSPACE
                                Ansi.CtrlChars.TAB -> Keys.TAB
                                Ansi.CtrlChars.ENTER -> Keys.ENTER
                                Ansi.CtrlChars.ESC -> {
                                    escSeq.append(c)
                                    // This is kind of ugly, but we need to detect the difference between the user
                                    // pressing ESC on their own vs it being the first character in a chain of an escape
                                    // sequence generated by the terminal. If the terminal generates an escape sequence,
                                    // the whole thing is consumed sub millisecond, so waiting a couple dozen ms to be
                                    // sure we aren't getting any followup characters. Note that a user can hold the
                                    // keys down which generates a bunch of key signals, so we additionally make sure
                                    // there hasn't been any other key pressed.
                                    CoroutineScope(ioDispatcher).launch {
                                        val delayMs = 50L
                                        var doneWaiting = false
                                        var sendEsc = false
                                        while (!doneWaiting) {
                                            delay(10L)
                                            keyLock.withLock {
                                                if (getCurrentTimeMs() - lastKeyTime > delayMs) {
                                                    sendEsc = escSeq.length == 1 && escSeq.contains(Ansi.CtrlChars.ESC)
                                                    if (sendEsc) escSeq.clear()
                                                    doneWaiting = true
                                                }
                                            }
                                        }
                                        if (sendEsc) send(Keys.ESC)
                                    }
                                    null
                                }
                                else -> if (!c.isISOControl()) CharKey(c) else null
                            }
                        }
                    }
                }

                if (key != null) {
                    send(key)
                }
            }
        }
            // We only want to collect keypresses in one place per session. Use shareIn so collecters don't spawn new
            // flows. For example, multiple flows here would really mess with the escSeq logic
            .shareIn(CoroutineScope(ioDispatcher), SharingStarted.Lazily)
    }
}



/** State needed to support the `input()` function */
private class InputState(val id: Any, val cursorState: BlinkingCursorState) {
    var isActive = false

    private var _text = ""
    private var _cursorIndex = 0

    var text
        get() = _text
        set(value) {
            if (_text != value) {
                _text = value
                _cursorIndex = _text.length
                if (isActive) cursorState.resetCursor()
            }
        }

    var cursorIndex
        get() = _cursorIndex
        set(value) {
            @Suppress("NAME_SHADOWING")
            val value = value.coerceAtMost(_text.length)
            if (_cursorIndex != value) {
                _cursorIndex = value
                if (isActive) cursorState.resetCursor()
            }
        }
}

// Exposed for testing
internal const val BLINKING_DURATION_MS = 500

private class BlinkingCursorState {
    var blinkOn = true
    var blinkElapsedMs = 0

    fun resetCursor() {
        blinkOn = true
        blinkElapsedMs = 0
    }

    /** Elapse the timer on this input state's cursor animation, returning true if the cursor actually changed. */
    fun elapse(duration: Duration): Boolean {
        val prevBlinkOn = blinkOn
        blinkElapsedMs += duration.inWholeMilliseconds.toInt()
        while (blinkElapsedMs >= BLINKING_DURATION_MS) {
            blinkElapsedMs -= BLINKING_DURATION_MS
            blinkOn = !blinkOn
        }
        return prevBlinkOn != blinkOn
    }
}

private val InputStatesKey = Section.Lifecycle.createKey<MutableMap<Any, InputState>>()
private val BlinkingCursorStateKey = Section.Lifecycle.createKey<BlinkingCursorState>()
private val InputStatesCalledThisRender = MainRenderScope.Lifecycle.createKey<MutableMap<Any, InputState>>()
private val UpdateInputJobKey = Section.Lifecycle.createKey<Job>()


private fun ConcurrentScopedData.activate(state: InputState) {
    if (state.isActive) return
    get(InputActivatedCallbackKey) {
        val onInputActivatedScope = OnInputActivatedScope(state.id, state.text)
        this.invoke(onInputActivatedScope)
        state.text = onInputActivatedScope.input
    }
    state.isActive = true
}

private fun ConcurrentScopedData.deactivate(state: InputState) {
    if (!state.isActive) return
    get(InputDeactivatedCallbackKey) {
        val onInputDeactivatedScope = OnInputDeactivatedScope(state.id, state.text)
        this.invoke(onInputDeactivatedScope)
        state.text = onInputDeactivatedScope.input
    }
    state.isActive = false
}

/**
 * If necessary, instantiate data that the [input] method expects to exist.
 *
 * Is a no-op after the first time.
 */
private fun ConcurrentScopedData.prepareInput(scope: MainRenderScope, id: Any, initialText: String, isActive: Boolean) {
    val section = scope.section
    prepareKeyFlow(section.session.terminal, section.session.dispatchers.io)
    val cursorState = putOrGet(BlinkingCursorStateKey) {
        val cursorState = BlinkingCursorState()
        // This block represents global state that gets triggered just once for all input blocks in this section, so we
        // do some quick init side effects as well

        addTimer(section.session.dispatchers.io, Anim.ONE_FRAME_60FPS, repeat = true, key = cursorState) {
            if (cursorState.elapse(elapsed)) {
                section.requestRerender()
            }
        }

        section.onRendered {
            // We need to indirectly detect if a previously active input state was not called this frame. This can
            // happen either if we called OTHER input states this frame OR if we called NO input states this frame.
            // We can detect both of these cases by querying the "input states called this render" key.
            val idsRenderedThisFrame = mutableSetOf<Any>()
            remove(InputStatesCalledThisRender) {
                idsRenderedThisFrame.addAll(this.keys)
            }
            get(InputStatesKey) {
                val unrenderedActiveInputStates = this.values.filter { it.isActive && !idsRenderedThisFrame.contains(it.id) }
                if (unrenderedActiveInputStates.isNotEmpty()) {
                    unrenderedActiveInputStates.forEach { deactivate(it) }
                }
            }

            if (idsRenderedThisFrame.isEmpty()) {
                // A minor touch, but always make sure the cursor starts from scratch anytime a new input method is
                // called in the future
                cursorState.resetCursor()
            }
        }

        section.onFinishing {
            // If we are exiting the block but by chance the blinking cursor was on, turn it off!
            if (cursorState.blinkOn) {
                cursorState.resetCursor()
                cursorState.blinkOn = false
                section.requestRerender()
            }
        }

        cursorState
    }!!

    putIfAbsent(InputStatesKey, provideInitialValue = { mutableMapOf() }) {
        val inputStates = this
        val state = inputStates.computeIfAbsent(id) {
            val newState = InputState(id, cursorState)
            newState.text = initialText
            newState.cursorIndex = initialText.length
            newState
        }

        putIfAbsent(InputStatesCalledThisRender, provideInitialValue = { mutableMapOf() }) {
            val renderedInputStates = this
            if (renderedInputStates.contains(id)) {
                throw IllegalStateException("Got more than one `input` in a single render pass with ID $id")
            }
            if (isActive && renderedInputStates.values.any { it.isActive }) {
                throw IllegalStateException("Having more than one active `input` in a single render pass is not supported")
            }
            renderedInputStates[id] = state
        }

        if (state.isActive != isActive) {
            if (isActive) {
                activate(state)
            } else {
                deactivate(state)
            }
        }
    }

    tryPut(
        UpdateInputJobKey,
        provideInitialValue = {
            CoroutineScope(section.session.dispatchers.io).launch {
                getValue(KeyFlowKey).collect { key ->
                    withActiveInput {
                        val prevText = text
                        val prevCursorIndex = cursorIndex
                        var proposedText: String? = null
                        var proposedCursorIndex: Int? = null
                        when (key) {
                            Keys.LEFT -> cursorIndex = (cursorIndex - 1).coerceAtLeast(0)
                            Keys.RIGHT -> {
                                if (cursorIndex < text.length) {
                                    cursorIndex++
                                }
                                else {
                                    get(CompleterKey) {
                                        complete(text)?.let { completion ->
                                            val finalText = text + completion
                                            proposedText = finalText
                                            proposedCursorIndex = finalText.length
                                        }
                                    }
                                }
                            }
                            Keys.HOME -> cursorIndex = 0
                            Keys.END -> cursorIndex = text.length
                            Keys.DELETE -> {
                                if (cursorIndex <= text.lastIndex) {
                                    proposedText = text.removeRange(cursorIndex, cursorIndex + 1)
                                    proposedCursorIndex = cursorIndex
                                }
                            }

                            Keys.BACKSPACE -> {
                                if (cursorIndex > 0) {
                                    proposedText = text.removeRange(cursorIndex - 1, cursorIndex)
                                    proposedCursorIndex = cursorIndex - 1
                                }
                            }

                            Keys.ENTER -> {
                                var rejected = false
                                var cleared = false
                                get(InputEnteredCallbackKey) {
                                    val onInputEnteredScope = OnInputEnteredScope(id, text)
                                    this.invoke(onInputEnteredScope)
                                    rejected = onInputEnteredScope.rejected
                                    cleared = onInputEnteredScope.cleared
                                }
                                if (cleared) {
                                    getValue(InputStatesKey).remove(id)
                                }
                                if (!rejected) {
                                    get(SystemInputEnteredCallbackKey) { this.invoke() }
                                }
                            }
                            else ->
                                if (key is CharKey) {
                                    proposedText = "${text.take(cursorIndex)}${key.code}${text.takeLast(text.length - cursorIndex)}"
                                    proposedCursorIndex = cursorIndex + 1
                                }
                        }

                        if (proposedText != null) {
                            get(InputChangedCallbackKey) {
                                val onInputChangedScope = OnInputChangedScope(id, input = proposedText!!, prevInput = text)
                                this.invoke(onInputChangedScope)

                                if (!onInputChangedScope.rejected) {
                                    proposedText = onInputChangedScope.input
                                } else {
                                    proposedText = onInputChangedScope.prevInput
                                    proposedCursorIndex = cursorIndex
                                }
                            }

                            text = proposedText!!
                            cursorIndex = (proposedCursorIndex ?: cursorIndex).coerceIn(0, text.length)
                        }

                        if (text != prevText || cursorIndex != prevCursorIndex) {
                            section.requestRerender()
                        }
                    }
                }
            }
        },
        dispose = { job -> job.cancel() }
    )
}

/**
 * Fetch the current value of some [input] call from anywhere within a [RunScope.run] block, if one is set.
 *
 * You should ideally only check input values within [onInputChanged], [onInputEntered] etc. callbacks, but for edge
 * cases it may be useful to fetch input outside of those events.
 *
 * See also: [input], [setInput]
 *
 * @param id If set, find the input with the matching ID. This can be useful if you have multiple input blocks defined
 *   at the same time.
 */
fun SectionScope.getInput(id: Any = Unit): String? {
    var input: String? = null
    data.get(InputStatesKey) { input = this[id]?.text }
    return input
}

/**
 * Set the value for some [input] call directly from anywhere in a [RunScope.run] block.
 *
 * This should be extremely rare to do! But perhaps you need to set the text asynchronously
 * (e.g. [onInputEntered] is blocking) or inside on [onKeyPressed] callback, etc.
 *
 * However, try using [onInputChanged], [onInputEntered], etc. first. This will result in code that is easier for
 * readers to follow.
 *
 * See also: [input], [getInput]
 *
 * @param text The text to replace the current input with
 * @param cursorIndex If specified, the index of the cursor position; otherwise, it will be placed after the end of the
 *   text.
 * @param id If set, find the input with the matching ID. This can be useful if you have multiple input blocks defined
 *   at the same time.
 */
fun RunScope.setInput(text: String, cursorIndex: Int = text.length, id: Any = Unit) {
    data.get(InputStatesKey) {
        this[id]?.apply {
            if (this.text != text || this.cursorIndex != cursorIndex) {
                this.text = text
                this.cursorIndex = cursorIndex

                rerender()
            }
        }
    }
}

/**
 * Interface for a class that can provide suggested auto-completions for an [input] call, given some initial text.
 */
interface InputCompleter {
    /**
     * Given some [input], return a suffix that should complete it, or null if the string does not have a matching
     * completion.
     *
     * For example, for `"y"`, you might return `"es"`.
     */
    fun complete(input: String): String?

    val color: Color get() = Color.BRIGHT_BLACK
}

/**
 * A default [InputCompleter] that provides completions given a list of possible values.
 *
 * For example:
 *
 * ```
 * input(Completions("yes", "no"))
 * ```
 *
 * will suggest `"yes"` for `""`, `"y"`, and `"ye"`, while suggesting `"no"` for `"n"`.
 *
 * If there are multiple matches, e.g. `"Colorado"` and `"Connecticut"` for `"co"`, the item earlier in the list will be
 * suggested as the completion.
 */
open class Completions(private vararg val values: String, private val ignoreCase: Boolean = true) : InputCompleter {
    override fun complete(input: String): String? {
        return values.firstOrNull { value ->
            value.startsWith(input, ignoreCase)
        }?.substring(input.length)
    }
}

private val CompleterKey = Section.Lifecycle.createKey<InputCompleter>()

/**
 * Information passed into the `viewMap` callback in the [input][com.varabyte.kotter.foundation.input.input] method.
 *
 * The user can check the current character being transformed (via the [ch] property), but the entire [input] so far and
 * the character's [index] into it are also provided in case the context helps with the mapping. It's expected that none
 * of these values will be needed in many cases, e.g. masking a password, but you can refer to them if you need to!
 *
 * For an example, to visually render all input text as uppercase (while the underlying input will be whatever case the
 * user typed in), you could call:
 *
 * ```
 * input(viewMap = { ch.uppercaseChar() })
 * ```
 *
 * or for masking a password, simply:
 *
 * ```
 * input(viewMap = { '*' })
 * ```
 *
 * @property input The backing text associated with the [input][com.varabyte.kotter.foundation.input.input] call.
 * @property index The index of the current character in the string being mapped.
 */
class ViewMapScope(val input: String, val index: Int) {
    /**
     * The current source character being mapped.
     *
     * This is a convenience property identical to `input[index]`.
     */
    val ch: Char = input[index]
}

/**
 * A function which, when called, will replace itself dynamically with text typed by the user, plus a blinking cursor.
 *
 * You can use the `onInputChanged` and `onInputEntered` callbacks to query the value as the user types it / commits it:
 *
 * ```
 * var name = ""
 * section {
 *   text("Enter your name: "); input()
 * }.runUntilInputEntered {
 *   onInputEntered {
 *     name = input // here, "input" is what the user typed in
 *   }
 * }
 * ```
 *
 * Usually you'll only need to call `input()` once in a whole section, but occasionally you may use more than one.
 *
 * There are two main cases:
 *
 * **1 - Only one input is shown at a time, but the inputs are different.**
 *
 * ```
 * when (state) {
 *   ASK_NAME -> text("Your name? "); input(id = "name")
 *   ASK_AGE -> text("Your age? "); input(id = "age")
 *   ...
 * }
 * ...
 * onKeyPressed {
 *   Keys.TAB -> state = state.next()
 * }
 * ```
 *
 * In this case, you should ensure that each input has a unique ID, so that Kotter realizes that a new input has gotten
 * focus, and can show its last known value.
 *
 * **2 - Multiple inputs are shown at the same time.**
 * ```
 * text("Red value:   "); input(id = "red", isActive = (state == EDIT_RED))
 * text("Green value: "); input(id = "green", isActive = (state == EDIT_GREEN))
 * text("Blue value:  "); input(id = "blue", isActive = (state == EDIT_BLUE))
 * ...
 * onKeyPressed {
 *   Keys.TAB -> state = state.next()
 * }
 * ```
 *
 * In addition to using unique IDs per input, you should make sure your logic works so that at most only one of them is
 * active at a time. If you call `input()` twice in a single section with both being active, it'll throw a runtime
 * exception.
 *
 * @param completer Optional logic for suggesting auto-completions based on what the user typed in. See
 *   [Completions] which is a generally useful and common implementation.
 * @param initialText Text which will be used the first time `input()` is called and ignored subsequently.
 * @param id See docs above for more details. The value of this parameter can be anything - this method simply does an
 *   equality check on it against a previous value.
 * @param viewMap If set, *visually* transform the text by specifying the target character each letter in the text
 *   should map to. This doesn't affect the input's actual value, just the value that is rendered on screen. This is
 *   particularly useful for password inputs, which would look like `viewMap = { '*' }`.
 * @param isActive See docs above for more details. If multiple calls to input are made in a single section, at most one
 *   of them can be active at a time.
 */
fun MainRenderScope.input(
    completer: InputCompleter? = null,
    initialText: String = "",
    id: Any = Unit,
    viewMap: ViewMapScope.() -> Char = { ch },
    isActive: Boolean = true) {
    data.prepareInput(this, id, initialText, isActive)
    completer?.let { data[CompleterKey] = it }

    with(data.getValue(InputStatesKey)[id]!!) {
        val transformedText =
            text.mapIndexed { i, _ -> ViewMapScope(text, i).viewMap() }.joinToString("")

        // Just asserting that for now this is always a 1:1 transformation. We may change this later but if we do, be
        // careful that cursor keys still work as expected.
        check(text.length == transformedText.length)

        // First, check the hard but common case. If we're the currently active input, render it with current
        // completions and cursor
        if (this.isActive) {
            val completion = try {
                completer?.complete(text)
            } catch (ex: Exception) {
                null
            } ?: ""


            // Note: Trailing space as cursor can be put AFTER last character
            val finalText = "$transformedText$completion "

            scopedState { // Make sure color changes don't leak
                for (i in finalText.indices) {
                    if (i == text.length && completer != null && completion.isNotEmpty()) {
                        color(completer.color)
                    }
                    if (i == cursorIndex && cursorState.blinkOn) {
                        invert()
                    }
                    text(finalText[i])
                    if (i == cursorIndex && cursorState.blinkOn) {
                        clearInvert()
                    }
                }
            }
        }
        // Otherwise, this input is dormant, and acts like normal text
        else {
            text(transformedText)
        }
    }
}

/**
 * Fields accessible within a callback triggered by [onKeyPressed].
 *
 * @property key The key that was pressed. See also: [Keys]
 */
class OnKeyPressedScope(val key: Key)

private val KeyPressedJobKey = RunScope.Lifecycle.createKey<Job>()
private val KeyPressedCallbackKey = RunScope.Lifecycle.createKey<OnKeyPressedScope.() -> Unit>()
// Note: We create a separate key here from above to ensure we can trigger the system callback only AFTER the user
// callback was triggered. That's because the system handler may fire a signal which, if sent out too early, could
// result in the user callback not getting a chance to run.
private val SystemKeyPressedCallbackKey = RunScope.Lifecycle.createKey<OnKeyPressedScope.() -> Unit>()

/**
 * Start running a job that collects keypresses and sends them to callbacks.
 *
 * This is a no-op when called after the first time.
 */
private fun ConcurrentScopedData.prepareOnKeyPressed(terminal: Terminal, ioDispatcher: CoroutineDispatcher) {
    prepareKeyFlow(terminal, ioDispatcher)
    tryPut(
        KeyPressedJobKey,
        provideInitialValue = {
            CoroutineScope(ioDispatcher).launch {
                getValue(KeyFlowKey).collect { key ->
                    val scope = OnKeyPressedScope(key)
                    get(KeyPressedCallbackKey) { this.invoke(scope) }
                    get(SystemKeyPressedCallbackKey) { this.invoke(scope) }
                }
            }
        },
        dispose = { job -> job.cancel() }
    )
}

/**
 * A handler you can register in a [RunScope.run] block to intercept keypresses.
 *
 * For example:
 *
 * ```
 * section { ... }.run {
 *   onKeyPressed {
 *     when (key) {
 *       Keys.SPACE -> ...
 *       Keys.ESC -> ...
 *     }
 *   }
 * }
 * ```
 */
fun RunScope.onKeyPressed(listener: OnKeyPressedScope.() -> Unit) {
    data.prepareOnKeyPressed(section.session.terminal, section.session.dispatchers.io)
    if (!data.tryPut(KeyPressedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onKeyPressed` callback at a time is supported.")
    }
}

/**
 * A `run` block which runs until one of the specified keys is pressed by the user.
 *
 * As a minimal example:
 *
 * ```
 * section {
 *   textLine("Press Q to quit.")
 *   ...
 * }.runUntilKeyPressed(Keys.Q) {
 *   ...
 * }
 * ```
 */

fun Section.runUntilKeyPressed(vararg keys: Key, block: suspend RunScope.() -> Unit = {}) {
    run {
        data.prepareOnKeyPressed(section.session.terminal, section.session.dispatchers.io)
        // We need to abort as even if the user puts a while(true) in their run block, we still want to exit
        data[SystemKeyPressedCallbackKey] = { if (keys.contains(key)) abort() }
        block()
        CompletableDeferred<Unit>().await() // The only way out of this function is by aborting
    }
}


/**
 * Fields accessible within a callback triggered by [onInputActivated].
 *
 * @property id The ID of the current input, if one was specified in the original call to [input][com.varabyte.kotter.foundation.input.input].
 * @property input The current text value of the input.
 */
class OnInputActivatedScope(val id: Any, var input: String)
private val InputActivatedCallbackKey = RunScope.Lifecycle.createKey<OnInputActivatedScope.() -> Unit>()

private fun ConcurrentScopedData.withActiveInput(block: InputState.() -> Unit) {
    get(InputStatesKey) {
        values.find { it.isActive }?.block()
    }
}

/**
 * A callback you can register in a [RunScope.run] block that will get triggered any time an [input] gains focus.
 *
 * For example:
 *
 * ```
 * section {
 *   when (state) {
 *     ASK_NAME -> text("Your name? "); input(id = "name")
 *     ASK_AGE -> text("Your age? "); input(id = "age")
 *     ...
 *   }
 * }.run {
 *   onInputActivated {
 *     when (id) {
 *       "name" -> ...
 *       "age" - > ...
 *     }
 *   }
 *   onKeyPressed {
 *     Keys.TAB -> state = state.next()
 *   }
 * }
 * ```
 */
fun RunScope.onInputActivated(listener: OnInputActivatedScope.() -> Unit) {
    if (!data.tryPut(InputActivatedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputActivated` callback at a time is supported.")
    } else {
        // There may already be an active input when this callback was registered.
        data.withActiveInput {
            val onInputActivatedScope = OnInputActivatedScope(id, text)
            listener(onInputActivatedScope)
            text = onInputActivatedScope.input
        }
    }
}

/**
 * Fields accessible within a callback triggered by [onInputDeactivated].
 *
 * @property id The ID of the current input, if one was specified in the original call to [input][com.varabyte.kotter.foundation.input.input].
 * @property input The current text value of the input.
 */
class OnInputDeactivatedScope(val id: Any, var input: String)
private val InputDeactivatedCallbackKey = RunScope.Lifecycle.createKey<OnInputDeactivatedScope.() -> Unit>()

/**
 * A callback you can register in a [RunScope.run] block that will get triggered any time an [input] loses focus.
 *
 * For example:
 *
 * ```
 * section {
 *   when (state) {
 *     ASK_NAME -> text("Your name? "); input(id = "name")
 *     ASK_AGE -> text("Your age? "); input(id = "age")
 *     ...
 *   }
 * }.run {
 *   onInputDeactivated {
 *     when (id) {
 *       "name" -> ...
 *       "age" - > ...
 *     }
 *   }
 *   onKeyPressed {
 *     Keys.TAB -> state = state.next()
 *   }
 * }
 * ```
 */
fun RunScope.onInputDeactivated(listener: OnInputDeactivatedScope.() -> Unit) {
    if (!data.tryPut(
            InputDeactivatedCallbackKey,
            provideInitialValue = { listener },
            dispose = {
                val states = data[InputStatesKey] ?: return@tryPut
                val activeState = states.values.firstOrNull { it.isActive } ?: return@tryPut
                data.deactivate(activeState)
            }
        )
    ) {
        throw IllegalStateException("Currently only one `onInputDeactivated` callback at a time is supported.")
    }
}

/**
 * Fields and methods accessible within a callback triggered by [onInputChanged].
 *
 * @property id The ID of the current input, if one was specified in the original call to [input][com.varabyte.kotter.foundation.input.input].
 * @property input The text value of the input entered by the user. This value can be modified, which will affect the
 *   final input rendered.
 * @property prevInput The previous (last good) state of the input.
 */
class OnInputChangedScope(val id: Any, var input: String, val prevInput: String) {
    internal var rejected = false
    /** Indicate that the current [input] change isn't valid and the last state should be restored. */
    fun rejectInput() { rejected = true }
}
private val InputChangedCallbackKey = RunScope.Lifecycle.createKey<OnInputChangedScope.() -> Unit>()

/**
 * A callback you can register in a [RunScope.run] block that will get triggered any time the changes their [input].
 *
 * The user's input will be provided via the [OnInputChangedScope.input] property. This value can be intercepted and
 * edited at this point.
 *
 * You can also call [OnInputChangedScope.rejectInput] to indicate that the last change should be rejected.
 *
 * For example:
 *
 * ```
 * section {
 *   text("First name: "); input()
 * }.run {
 *   onInputChanged {
 *     if (input.any { !it.isLetter }) rejectInput()
 *   }
 * }
 * ```
 */
fun RunScope.onInputChanged(listener: OnInputChangedScope.() -> Unit) {
    if (!data.tryPut(InputChangedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputChanged` callback at a time is supported.")
    }
}

/**
 * Fields and methods accessible within a callback triggered by [onInputEntered].
 *
 * @property id The ID of the current input, if one was specified in the original call to [input][com.varabyte.kotter.foundation.input.input].
 * @property input The text value of the input entered by the user. At this point, the value is readonly. See also:
 *   [onInputChanged], a callback that lets you modify this value as it is being typed.
 */
class OnInputEnteredScope(val id: Any, val input: String) {
    internal var rejected = false
    /** Indicate that the current [input] isn't valid and shouldn't be accepted as is. */
    fun rejectInput() { rejected = true }
    internal var cleared = false
    /**
     * Call to reset the input back to blank, which can be useful if you are re-using the same [input] multiple times.
     */
    fun clearInput() { cleared = true }
}
private val InputEnteredCallbackKey = RunScope.Lifecycle.createKey<OnInputEnteredScope.() -> Unit>()

// Note: We create a separate key here from above to ensure we can trigger the system callback only AFTER the user
// callback was triggered. That's because the system handler may fire a signal which, if sent out too early, could
// result in the user callback not getting a chance to run.
private object SystemInputEnteredCallbackKey : ConcurrentScopedData.Key<() -> Unit> {
    override val lifecycle = RunScope.Lifecycle
}

/**
 * A callback you can register in a [RunScope.run] block which will get triggered any time the user presses the ENTER
 * key an [input] area that has focus.
 *
 * The user's input will be provided via the [OnInputEnteredScope.input] property. This is a good time to update any
 * local variables you have that depend on the user's input, and possibly end the current section.
 *
 * Here's a common pattern, combined with [runUntilInputEntered] to handle exiting the block when the input has been
 * accepted:
 *
 * ```
 * var name = ""
 * section {
 *   text("Name: "); input()
 * }.runUntilInputEntered {
 *   onInputEntered {
 *     name = input
 *   }
 * }
 * ```
 *
 * You can call [OnInputEnteredScope.rejectInput] to indicate that the input still needs to change before it can be
 * accepted.
 */
fun RunScope.onInputEntered(listener: OnInputEnteredScope.() -> Unit) {
    if (!data.tryPut(InputEnteredCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputEntered` callback at a time is supported.")
    }
}

/**
 * A `run` block which runs until the user has pressed ENTER on some currently active [input].
 *
 * As a minimal example:
 *
 * ```
 * var name: String = ""
 * section {
 *   text("Name: "); input()
 * }.runUntilInputEntered {
 *   onInputEntered { name = input }
 * }
 * ```
 */
fun Section.runUntilInputEntered(block: suspend RunScope.() -> Unit = {}) {
    run {
        // We need to abort as even if the user puts a while(true) in their run block, we still want to exit
        data[SystemInputEnteredCallbackKey] = { abort() }
        block()
        CompletableDeferred<Unit>().await() // The only way out of this function is by aborting
    }
}