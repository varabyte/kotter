package com.varabyte.kotter.foundation.input

import com.varabyte.kotter.foundation.anim.Anim
import com.varabyte.kotter.foundation.text.*
import com.varabyte.kotter.foundation.timer.addTimer
import com.varabyte.kotter.runtime.MainRenderScope
import com.varabyte.kotter.runtime.RunScope
import com.varabyte.kotter.runtime.Session
import com.varabyte.kotter.runtime.Section
import com.varabyte.kotter.runtime.concurrent.ConcurrentScopedData
import com.varabyte.kotter.runtime.concurrent.createKey
import com.varabyte.kotter.runtime.internal.ansi.Ansi
import com.varabyte.kotter.runtime.terminal.Terminal
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import java.time.Duration
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

// Once created, we keep it alive for the session, because Flow is designed to be collected multiple times, meaning
// there's no reason for us to keep recreating it. It's pretty likely that if a session uses input in one block, it
// will use input again in others. (We can always revisit this decision later and scope this to a Section lifecycle
// instead)
private val KeyFlowKey = Session.Lifecycle.createKey<Flow<Key>>()

/**
 * Create a [Flow<Key>] value which converts bytes read from a terminal into keys, handling some gnarly multi-byte
 * cases and smoothing over other inconsistent, historical legacy.
 */
private fun ConcurrentScopedData.prepareKeyFlow(terminal: Terminal) {
    tryPut(KeyFlowKey) {
        val keyLock = ReentrantLock()
        val escSeq = StringBuilder()
        var lastKeyTime: Long
        channelFlow {
            terminal.read().collect { byte ->
                val c = byte.toChar()
                val key = keyLock.withLock {
                    lastKeyTime = System.currentTimeMillis()
                    when {
                        escSeq.isNotEmpty() -> {
                            escSeq.append(c)
                            val code = Ansi.EscSeq.toCode(escSeq)
                            if (code != null) {
                                escSeq.clear()
                                when (code) {
                                    Ansi.Csi.Codes.Keys.UP -> Keys.UP
                                    Ansi.Csi.Codes.Keys.DOWN -> Keys.DOWN
                                    Ansi.Csi.Codes.Keys.LEFT -> Keys.LEFT
                                    Ansi.Csi.Codes.Keys.RIGHT -> Keys.RIGHT
                                    Ansi.Csi.Codes.Keys.HOME, Ansi.Csi.Codes.Cursor.MOVE_TO_LINE_START -> Keys.HOME
                                    Ansi.Csi.Codes.Keys.INSERT -> Keys.INSERT
                                    Ansi.Csi.Codes.Keys.DELETE -> Keys.DELETE
                                    Ansi.Csi.Codes.Keys.END, Ansi.Csi.Codes.Cursor.MOVE_TO_LINE_END -> Keys.END
                                    Ansi.Csi.Codes.Keys.PG_UP -> Keys.PAGE_UP
                                    Ansi.Csi.Codes.Keys.PG_DOWN -> Keys.PAGE_DOWN
                                    else -> null
                                }
                            } else {
                                null
                            }
                        }
                        else -> {
                            when (c) {
                                Ansi.CtrlChars.EOF -> Keys.EOF
                                // Windows uses BACKSPACE, *nix uses DELETE? Best to support both
                                Ansi.CtrlChars.BACKSPACE, Ansi.CtrlChars.DELETE -> Keys.BACKSPACE
                                Ansi.CtrlChars.TAB -> Keys.TAB
                                Ansi.CtrlChars.ENTER -> Keys.ENTER
                                Ansi.CtrlChars.ESC -> {
                                    escSeq.append(c)
                                    // This is kind of ugly but we need to detect the difference between the user pressing
                                    // ESC on their own vs it being the first character in a chain of an escape sequence
                                    // generated by the terminal. If the terminal generates an escape sequence, the whole
                                    // thing is consumed sub millisecond, so waiting a couple dozen ms to be sure we aren't
                                    // getting any followup characters. Note that a user can hold the keys down which
                                    // generates a bunch of key signals, so we additionally make sure there hasn't been
                                    // any other key pressed
                                    CoroutineScope(Dispatchers.IO).launch {
                                        val delayMs = 50L
                                        var doneWaiting = false
                                        var sendEsc = false
                                        while (!doneWaiting) {
                                            delay(10L)
                                            keyLock.withLock {
                                                if (System.currentTimeMillis() - lastKeyTime > delayMs) {
                                                    sendEsc = escSeq.length == 1 && escSeq.contains(Ansi.CtrlChars.ESC)
                                                    if (sendEsc) escSeq.clear()
                                                    doneWaiting = true
                                                }
                                            }
                                        }
                                        if (sendEsc) send(Keys.ESC)
                                    }
                                    null
                                }
                                else -> if (!c.isISOControl()) CharKey(c) else null
                            }
                        }
                    }
                }

                if (key != null) {
                    send(key)
                }
            }
        }
            // We only want to collect keypresses in one place per session. Use shareIn so collecters don't spawn new
            // flows. For example, multiple flows here would really mess with the escSeq logic
            .shareIn(CoroutineScope(Dispatchers.IO), SharingStarted.Lazily)
    }
}



/** State needed to support the `input()` function */
private class InputState(val id: Any, val cursorState: BlinkingCursorState) {
    var isActive = false

    private var _text = ""
    private var _index = 0

    var text
        get() = _text
        set(value) {
            if (_text != value) {
                _text = value
                _index = _text.length
                if (isActive) cursorState.resetCursor()
            }
        }

    var index
        get() = _index
        set(value) {
            @Suppress("NAME_SHADOWING")
            val value = value.coerceAtMost(_text.length)
            if (_index != value) {
                _index = value
                if (isActive) cursorState.resetCursor()
            }
        }
}

private class BlinkingCursorState {
    companion object {
        private const val BLINKING_DURATION_MS = 500
    }

    var blinkOn = true
    var blinkElapsedMs = 0

    fun resetCursor() {
        blinkOn = true
        blinkElapsedMs = 0
    }

    /** Elapse the timer on this input state's cursor animation, returning true if the cursor actually changed. */
    fun elapse(duration: Duration): Boolean {
        val prevBlinkOn = blinkOn
        blinkElapsedMs += duration.toMillis().toInt()
        while (blinkElapsedMs > BLINKING_DURATION_MS) {
            blinkElapsedMs -= BLINKING_DURATION_MS
            blinkOn = !blinkOn
        }
        return prevBlinkOn != blinkOn
    }
}

private val InputStatesKey = Section.Lifecycle.createKey<MutableMap<Any, InputState>>()
private val BlinkingCursorStateKey = Section.Lifecycle.createKey<BlinkingCursorState>()
private val ActiveInputCalledThisRenderKey = MainRenderScope.Lifecycle.createKey<Unit>()
private val UpdateInputJobKey = Section.Lifecycle.createKey<Job>()

/**
 * If necessary, instantiate data that the [input] method expects to exist.
 *
 * Is a no-op after the first time.
 */
private fun ConcurrentScopedData.prepareInput(scope: MainRenderScope, id: Any, initialText: String, isActive: Boolean) {
    if (isActive) {
        if (this.contains(ActiveInputCalledThisRenderKey)) {
            throw IllegalStateException("Having more than one active `input` in a single render pass is not supported")
        } else {
            this[ActiveInputCalledThisRenderKey] = Unit
        }
    }

    val section = scope.section
    prepareKeyFlow(section.session.terminal)
    val cursorState = putOrGet(BlinkingCursorStateKey) {
        val cursorState = BlinkingCursorState()
        // This block represents global state that gets triggered just once for all input blocks in this section, so we
        // do some quick init side effects as well

        addTimer(Anim.ONE_FRAME_60FPS, repeat = true, key = cursorState) {
            if (cursorState.elapse(elapsed)) {
                section.requestRerender()
            }
        }

        section.onRendered {
            // If no active inputs were rendered this frame, reset the cursor for the next time one
            // becomes active.
            if (!remove(ActiveInputCalledThisRenderKey)) {
                cursorState.resetCursor()
            }
        }

        section.onFinishing {
            // If we are exiting the block but by chance the blinking cursor was on, turn it off!
            if (cursorState.blinkOn) {
                cursorState.resetCursor()
                section.requestRerender()
            }
        }

        cursorState
    }!!

    putIfAbsent(InputStatesKey, provideInitialValue = { mutableMapOf() }) {
        val inputStates = this
        val state = inputStates.computeIfAbsent(id) {
            val newState = InputState(id, cursorState)
            newState.text = initialText
            newState.index = initialText.length
            newState
        }
        if (state.isActive != isActive) {
            if (isActive) {
                get(InputActivatedCallbackKey) {
                    val onInputActivatedScope = OnInputActivatedScope(id, state.text)
                    this.invoke(onInputActivatedScope)
                    state.text = onInputActivatedScope.input
                }
            } else {
                get(InputDeactivatedCallbackKey) {
                    val onInputDeactivatedScope = OnInputDeactivatedScope(id, state.text)
                    this.invoke(onInputDeactivatedScope)
                    state.text = onInputDeactivatedScope.input
                }
            }
            state.isActive = isActive
        }
    }

    tryPut(
        UpdateInputJobKey,
        provideInitialValue = {
            CoroutineScope(Dispatchers.IO).launch {
                getValue(KeyFlowKey).collect { key ->
                    withActiveInput {
                        val prevText = text
                        val prevIndex = index
                        var proposedText: String? = null
                        var proposedIndex: Int? = null
                        when (key) {
                            Keys.LEFT -> index = (index - 1).coerceAtLeast(0)
                            Keys.RIGHT -> {
                                if (index < text.length) {
                                    index++
                                }
                                else {
                                    get(CompleterKey) {
                                        complete(text)?.let { completion ->
                                            val finalText = text + completion
                                            proposedText = finalText
                                            proposedIndex = finalText.length
                                        }
                                    }
                                }
                            }
                            Keys.HOME -> index = 0
                            Keys.END -> index = text.length
                            Keys.DELETE -> {
                                if (index <= text.lastIndex) {
                                    proposedText = text.removeRange(index, index + 1)
                                }
                            }

                            Keys.BACKSPACE -> {
                                if (index > 0) {
                                    proposedText = text.removeRange(index - 1, index)
                                    proposedIndex = index - 1
                                }
                            }

                            Keys.ENTER -> {
                                var rejected = false
                                var cleared = false
                                get(InputEnteredCallbackKey) {
                                    val onInputEnteredScope = OnInputEnteredScope(id, text)
                                    this.invoke(onInputEnteredScope)
                                    rejected = onInputEnteredScope.rejected
                                    cleared = onInputEnteredScope.cleared
                                }
                                if (!rejected) {
                                    get(SystemInputEnteredCallbackKey) { this.invoke() }
                                }
                                if (cleared) {
                                    getValue(InputStatesKey).remove(id)
                                }
                            }
                            else ->
                                if (key is CharKey) {
                                    proposedText = "${text.take(index)}${key.code}${text.takeLast(text.length - index)}"
                                    proposedIndex = index + 1
                                }
                        }

                        if (proposedText != null) {
                            get(InputChangedCallbackKey) {
                                val onInputChangedScope = OnInputChangedScope(id, input = proposedText!!, prevInput = text)
                                this.invoke(onInputChangedScope)

                                proposedText = if (!onInputChangedScope.rejected) onInputChangedScope.input else onInputChangedScope.prevInput
                            }

                            text = proposedText!!
                            index = (proposedIndex ?: index).coerceIn(0, text.length)
                        }

                        if (text != prevText || index != prevIndex) {
                            section.requestRerender()
                        }
                    }
                }
            }
        },
        dispose = { job -> job.cancel() }
    )
}

/**
 * Fetch the current input value in the run scope, if set.
 */
fun RunScope.getInput(id: Any = Unit): String? = data[InputStatesKey]?.get(id)?.text

interface InputCompleter {
    /**
     * Given some [input], return a suffix that should complete it, or null if the string does not have a matching
     * completion.
     *
     * For example, for "y", you might return "es"
     */
    fun complete(input: String): String?

    val color: Color get() = Color.BRIGHT_BLACK
}

/**
 * A default [InputCompleter] that provides completions given a list of values.
 *
 * If there are multiple matches, e.g. "Colorado" and "Connecticut" for "co", the item earlier in the list will be
 * suggested as the completion.
 */
open class Completions(private vararg val values: String, private val ignoreCase: Boolean = true) : InputCompleter {
    override fun complete(input: String): String? {
        return values.firstOrNull { value ->
            value.startsWith(input, ignoreCase)
        }?.substring(input.length)
    }
}

private val CompleterKey = Section.Lifecycle.createKey<InputCompleter>()

/**
 * A function which, when called, will replace itself dynamically with some input text plus a blinking cursor.
 *
 * You can only call `input()` ONCE each render pass - if you call it twice, you'll get a runtime exception.
 *
 * You can use the `onInputChanged` and `onInputEntered` callbacks to query the value as the user types it / commits it.
 *
 * ```
 * section {
 *   text("Enter your name: "); input()
 * }.run {
 *   onInputEntered {
 *     // here, "input" is what the user typed in
 *   }
 * }
 * ```
 *
 * Occasionally, you may call `input` across multiple cases:
 *
 * ```
 * when (state) {
 *   ASK_NAME -> text("Your name? "); input(id = "name")
 *   ASK_AGE -> text("Your age? "); input(id = "age")
 *   ...
 * }
 * ```
 *
 * Usually you would do this in separate sections, but perhaps you want to cycle through questions within the same
 * section for a particular UX feel.
 *
 * You can accomplish this two ways. One, pass in an ID for each input call, or call `clearInput` on `onInputEntered`.
 *
 * Approach #1, using IDs:
 * ```
 * when (state) {
 *   ASK_NAME -> text("Your name? "); input(id = "name")
 *   ASK_AGE -> text("Your age? "); input(id = "age")
 *   ...
 * }
 * ```
 *
 * Approach #2, using `clearInput`
 * ```
 * when (state) {
 *   ASK_NAME -> text("Your name? "); input()
 *   ASK_AGE -> text("Your age? "); input()
 *   ...
 * }.run {
 *   onInputEntered {
 *      if (state == ASK_NAME) {
 *        name = input
 *        clearInput()
 *        state = ASK_AGE
 *      } else if (state == ASK_AGE) {
 *        ...
 *      }
 *   }
 * }
 * ```
 *
 * @param completer Optional logic for suggesting auto-completions based on what the user typed in. See
 *   [Completions] which is a generally useful and common implementation.
 * @param initialText Text which will be used the first time `input()` is called and ignored subsequently.
 * @param id See docs above for more details. The value of this parameter can be anything - this method simply does an
 *   equality check on it against a previous value.
 */
fun MainRenderScope.input(completer: InputCompleter? = null, initialText: String = "", id: Any = Unit, isActive: Boolean = true) {
    data.prepareInput(this, id, initialText, isActive)
    completer?.let { data[CompleterKey] = it }

    with(data.getValue(InputStatesKey)[id]!!) {
        // First, check the hard but common case. If we're the currently active input, render it with current
        // completions and cursor
        if (this.isActive) {
            val completion = try {
                completer?.complete(text)
            } catch (ex: Exception) {
                null
            } ?: ""

            // Note: Trailing space as cursor can be put AFTER last character
            val finalText = "$text$completion "

            scopedState { // Make sure color changes don't leak
                for (i in finalText.indices) {
                    if (i == text.length && completer != null && completion.isNotEmpty()) {
                        color(completer.color)
                    }
                    if (i == index && cursorState.blinkOn) {
                        invert()
                    }
                    text(finalText[i])
                    if (i == index && cursorState.blinkOn) {
                        clearInvert()
                    }
                }
            }
        }
        // Otherwise, this input is dormant, and acts like normal text
        else {
            text(text)
        }
    }
}

class OnKeyPressedScope(val key: Key)

private val KeyPressedJobKey = RunScope.Lifecycle.createKey<Job>()
private val KeyPressedCallbackKey = RunScope.Lifecycle.createKey<OnKeyPressedScope.() -> Unit>()
// Note: We create a separate key here from above to ensure we can trigger the system callback only AFTER the user
// callback was triggered. That's because the system handler may fire a signal which, if sent out too early, could
// result in the user callback not getting a chance to run.
private val SystemKeyPressedCallbackKey = RunScope.Lifecycle.createKey<OnKeyPressedScope.() -> Unit>()

/**
 * Start running a job that collects keypresses and sends them to callbacks.
 *
 * This is a no-op when called after the first time.
 */
private fun ConcurrentScopedData.prepareOnKeyPressed(terminal: Terminal) {
    prepareKeyFlow(terminal)
    tryPut(
        KeyPressedJobKey,
        provideInitialValue = {
            CoroutineScope(Dispatchers.IO).launch {
                getValue(KeyFlowKey).collect { key ->
                    val scope = OnKeyPressedScope(key)
                    get(KeyPressedCallbackKey) { this.invoke(scope) }
                    get(SystemKeyPressedCallbackKey) { this.invoke(scope) }
                }
            }
        },
        dispose = { job -> job.cancel() }
    )
}

/** A handler you can register in a `run` block to intercept keypresses */
fun RunScope.onKeyPressed(listener: OnKeyPressedScope.() -> Unit) {
    data.prepareOnKeyPressed(section.session.terminal)
    if (!data.tryPut(KeyPressedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onKeyPressed` callback at a time is supported.")
    }
}

/** A `run` block which runs until one of the specified keys is pressed by the user. */
fun Section.runUntilKeyPressed(vararg keys: Key, block: suspend RunScope.() -> Unit = {}) {
    run {
        data.prepareOnKeyPressed(this.section.session.terminal)
        data[SystemKeyPressedCallbackKey] = { if (keys.contains(key)) abort() }
        block()
        CompletableDeferred<Unit>().await() // The only way out of this function is by aborting
    }
}

class OnInputActivatedScope(val id: Any, var input: String)
private val InputActivatedCallbackKey = RunScope.Lifecycle.createKey<OnInputActivatedScope.() -> Unit>()

private fun ConcurrentScopedData.withActiveInput(block: InputState.() -> Unit) {
    get(InputStatesKey) {
        values.find { it.isActive }?.block()
    }
}

fun RunScope.onInputActivated(listener: OnInputActivatedScope.() -> Unit) {
    if (!data.tryPut(InputActivatedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputActivated` callback at a time is supported.")
    } else {
        // There may already be an active input when this callback was registered.
        data.withActiveInput {
            val onInputActivatedScope = OnInputActivatedScope(id, text)
            listener(onInputActivatedScope)
            text = onInputActivatedScope.input
        }
    }
}

class OnInputDeactivatedScope(val id: Any, var input: String)
private val InputDeactivatedCallbackKey = RunScope.Lifecycle.createKey<OnInputDeactivatedScope.() -> Unit>()

fun RunScope.onInputDeactivated(listener: OnInputDeactivatedScope.() -> Unit) {
    if (!data.tryPut(InputDeactivatedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputDeactivated` callback at a time is supported.")
    }
}

class OnInputChangedScope(val id: Any, var input: String, val prevInput: String) {
    internal var rejected = false
    fun rejectInput() { rejected = true }
}
private val InputChangedCallbackKey = RunScope.Lifecycle.createKey<OnInputChangedScope.() -> Unit>()

fun RunScope.onInputChanged(listener: OnInputChangedScope.() -> Unit) {
    if (!data.tryPut(InputChangedCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputChanged` callback at a time is supported.")
    }
}

class OnInputEnteredScope(val id: Any, val input: String) {
    internal var rejected = false
    fun rejectInput() { rejected = true }
    internal var cleared = false
    fun clearInput() { cleared = true }
}
private val InputEnteredCallbackKey = RunScope.Lifecycle.createKey<OnInputEnteredScope.() -> Unit>()

// Note: We create a separate key here from above to ensure we can trigger the system callback only AFTER the user
// callback was triggered. That's because the system handler may fire a signal which, if sent out too early, could
// result in the user callback not getting a chance to run.
private object SystemInputEnteredCallbackKey : ConcurrentScopedData.Key<() -> Unit> {
    override val lifecycle = RunScope.Lifecycle
}

fun RunScope.onInputEntered(listener: OnInputEnteredScope.() -> Unit) {
    if (!data.tryPut(InputEnteredCallbackKey) { listener }) {
        throw IllegalStateException("Currently only one `onInputEntered` callback at a time is supported.")
    }
}

fun Section.runUntilInputEntered(block: suspend RunScope.() -> Unit = {}) {
    run {
        data[SystemInputEnteredCallbackKey] = { abort() }
        block()
        CompletableDeferred<Unit>().await() // The only way out of this function is by aborting
    }
}